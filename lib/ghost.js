// Generated by CoffeeScript 1.8.0

/*
Class of application Injector. Contains services and factories. May
containt service without factory (eg. application core items)

@note This class is inspired by angular dependency injection system
 */

(function() {
  var Ghost,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  Ghost = (function() {

    /*
    Initializes both, factories and services maps.
     */
    function Ghost() {
      this.resolve = __bind(this.resolve, this);
      this.factories = {};
      this.services = {};
    }


    /*
    Adds Factory to the factory map
    
    @note This will not create service (lazy loading)
     */

    Ghost.prototype.addFactory = function(key, factory) {
      return this.factories[key] = factory;
    };


    /*
    Adds Service to the services map
    
    @note This does not affect any factories. Setting different service
    with same name as one of factories will prevent factory from creating
    correct service
     */

    Ghost.prototype.addService = function(key, service) {
      return this.services[key] = service;
    };

    Ghost.prototype.getService = function(key) {
      var factory, service;
      service = this.services[key];
      if (service == null) {
        factory = this.factories[key];
        if (factory == null) {
          return null;
        }
        service = factory();
        this.services[key] = service;
      }
      return service;
    };

    Ghost.prototype.create = function(Constructor, dependencyList) {
      var dependant, instance;
      if (dependencyList == null) {
        dependencyList = null;
      }
      dependant = function() {};
      dependant.prototype = Constructor.prototype;
      instance = new dependant();
      this.call(Constructor, instance, dependencyList);
      return instance;
    };

    Ghost.prototype.call = function(func, instance, dependencyList) {
      var dependencies;
      if (dependencyList == null) {
        dependencyList = null;
      }
      dependencies = this.resolve(func, dependencyList);
      return func.apply(instance, dependencies);
    };

    Ghost.prototype.inject = function(func, instance, dependencyList) {
      var dependencies;
      if (dependencyList == null) {
        dependencyList = null;
      }
      dependencies = this.resolve(func, dependencyList);
      return func.bind.apply(func, [instance].concat(__slice.call(dependencies)));
    };

    Ghost.prototype.resolve = function(func, dependencyList) {
      var dependencies, key, keys, _i, _len;
      if (dependencyList == null) {
        dependencyList = null;
      }
      keys = this.getArguments(func);
      dependencies = [];
      if (dependencyList != null) {
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          dependencies.push(dependencyList[key]);
        }
      } else {
        dependencies = keys.map(this.getService, this);
      }
      return dependencies;
    };

    Ghost.prototype.getArguments = function(func) {
      var arg, args, functionArgs, i, trueArgs, _i, _ref;
      functionArgs = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
      args = func.toString().match(functionArgs)[1].split(',');
      trueArgs = [];
      for (i = _i = 0, _ref = args.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        arg = args[i].trim();
        if (arg !== '') {
          trueArgs.push(arg);
        }
      }
      return trueArgs;
    };

    return Ghost;

  })();

  if (typeof exports === "undefined") {
    this["Ghost"] = Ghost;
  } else {
    module.exports = Ghost;
  }

}).call(this);
